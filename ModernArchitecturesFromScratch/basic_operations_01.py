# AUTOGENERATED! DO NOT EDIT! File to edit: basic_operations.ipynb (unless otherwise specified).

__all__ = ['MNIST_URL', 'Path', 'set_trace', 'datasets', 'pickle', 'gzip', 'math', 'torch', 'tensor', 'random', 'pdb',
           'show_doc', 'is_equal', 'near', 'test_near', 'test_near_zero', 'normalize', 'get_mnist', 'get_stats',
           'show_im', 'matmul']

# Cell
#hide
from pathlib import Path
from IPython.core.debugger import set_trace
from fastai import datasets
import pickle, gzip, math, torch, matplotlib as mpl
import matplotlib.pyplot as plt
from nbdev.showdoc import show_doc

#the only torch import we will have in the project
from torch import tensor
import random
import pdb



MNIST_URL='http://deeplearning.net/data/mnist/mnist.pkl'

# Cell
def is_equal(a,b):
    "Test for equality between `a` and `b`"
    assert(a==b)

# Cell
#hide
def near(a,b):
    "Test if tensors `a` and `b` are the same within a small tolerance"
    return torch.allclose(a, b, rtol=1e-3, atol=1e-5)

# Cell
def test_near(a,b):
    "Test if tensors `a` and `b` are near within a small tolerance"
    if near(a,b) == True:
        print("good")
    else:
        print("not near")

# Cell
def test_near_zero(data, tol=1e-3):
    "Tests if tensor values are near zero under given 'tol'"
    assert data.abs() < tol; print(f'Near zero: {data}')

# Cell
def normalize(datasets, mean=None, std=None):
    "Normalizes according to given 'mean' and 'std' or mean of std of datasets if none given"
    if mean is None: mean = datasets.mean()
    if std is None: std = datasets.std()
    return (datasets - mean) / std

# Cell
def get_mnist():
    "Helper function to load `normalized` train and validation MNIST datasets"
    path = datasets.download_data(MNIST_URL, ext='.gz')
    with gzip.open(path, 'rb') as f:
        ((x_train, y_train), (x_valid, y_valid), _) = pickle.load(f, encoding='latin-1')

    xt,yt,xv,yv = map(tensor, (x_train, y_train, x_valid, y_valid))
    return normalize(xt).float(), yt.float(), normalize(xv, xt.mean(), xt.std()).float(), yv.float()

# Cell
def get_stats(data):
    "Print mean and standard deviation of given `data`"
    print (f'Mean: {data.mean()}')
    print (f'Std: {data.std()}')

# Cell
#hide
mpl.rcParams['image.cmap'] = 'gray'

# Cell
def show_im(image, size=28):
    "Displays 'image' or random 'image' from set if multiple given of given 'size'"
    im_size = image.flatten().shape[0]
    if im_size > size**2:
        image = image[random.randint(0,math.floor((im_size-1)/size**2))]
    plt.imshow(image.view(size,size))

# Cell
def matmul(a, b):
    "Perform matrix multiplication on `a` and `b`"
    ar, ac = a.shape
    br, bc = b.shape
    assert (ac == br)
    c = torch.zeros(ar,bc)
    for ar_in in range(ar):
        c[ar_in] += (a[ar_in].unsqueeze(-1) * b).sum(dim=0)

    return c