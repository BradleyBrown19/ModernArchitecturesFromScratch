# AUTOGENERATED! DO NOT EDIT! File to edit: basic_operations.ipynb (unless otherwise specified).

__all__ = ['MNIST_URL', 'Path', 'set_trace', 'datasets', 'pickle', 'gzip', 'math', 'torch', 'tensor', 'random', 'pdb',
           'is_equal', 'near', 'test_near', 'show_im', 'matmul']

# Cell
#hide
from pathlib import Path
from IPython.core.debugger import set_trace
from fastai import datasets
import pickle, gzip, math, torch, matplotlib as mpl
import matplotlib.pyplot as plt

#the only torch import we will have in the project
from torch import tensor
import random
import pdb



MNIST_URL='http://deeplearning.net/data/mnist/mnist.pkl'

# Cell
def is_equal(a,b):
    "Test for equality between `a` and `b`"
    assert(a==b)

# Cell
def near(a,b):
    "Test if tensors `a` and `b` are the same within a small tolerance"
    return torch.allclose(a, b, rtol=1e-3, atol=1e-5)

# Cell
def test_near(a,b):
    "API for testing if tensors are near"
    if near(a,b) == True:
        print("good")
    else:
        print("not near")

# Cell
#hide
mpl.rcParams['image.cmap'] = 'gray'

# Cell
def show_im(image, size=28):
    "Displays 'image' or random 'image' from set if multiple given of given 'size'"
    im_size = image.flatten().shape[0]
    if im_size > size**2:
        image = image[random.randint(0,math.floor((im_size-1)/size**2))]
    plt.imshow(image.view(size,size))

# Cell
def matmul(a, b):
    "Perform matrix multiplication on `a` and `b`"
    ar, ac = a.shape
    br, bc = b.shape
    assert (ac == br)
    c = torch.zeros(ar,bc)
    for ar_in in range(ar):
        c[ar_in] += (a[ar_in].unsqueeze(-1) * b).sum(dim=0)

    return c